---
title: 初始Python的yield
date: 2019-10-09 14:26:15
tags: Python
---
# 前言
最近初入门Python，基本的条件循环语句与大多数语言基本一致。基本类型现在也没有深入了解，能用就好。于是来到了入门一门新语言的第一道门槛——函数。作用域还没看懂，又突如其来的杀出了一个**yield**。
# 准备
在进入正题前，要先介绍下几个概念。首先是列表生成式（List Comprehensions），如下：
```python
f = [x for x in range(1, 10)] # f = [1, 2, 3, 4, 5, 6, 7, 8, 9]
f = [x + y for x in 'ABCDE' for y in '1234567'] # f 为 ABCDE 和 1234567 两个字符串的笛卡尔积
```
这种方法固然方便，但万一生成式的结果占用的内存较大时，就会耗费比较多的内存空间。因为它在内存中储存了整个列表。比如：
```python
f = [x ** 2 for x in range(1, 1000)]
```
为此，就可以引入第二个概念，生成器（Generator），比如：
```python
f = (x ** 2 for x in range(1, 1000))
```
在写法上，两者的差异很小，但实际的行为却千差万别。生成器是一个对象，它本身并不会储存任何计算结果，只是每次需要的时候，就会执行一次计算并将结果返回。
# 斐波那契数列
接下来就开始介绍yield的用法，似乎大部分文章在这里都举了斐波那契数列的例子，那我也跟随一下吧。**要注意的是，下面的内容可能需要一些对斐波那契数列实现的了解作为基础。**

可以写出一个函数，它返回斐波那契数列前N个数组成的list：
```python
def fab(N): 
   n, first, second = 0, 0, 1 
   result = [] 
   while n < N: 
       result.append(second) 
       first, second = second, first + second 
       n = n + 1 
   return result
```
这个函数没什么问题，能很好地工作。但有人可能会觉得，“我一次只用一个斐波那契数列里的数，你一下子把整个list算出来，占用的内存太大了。”

那能怎么办？如果不用list存下之前计算的结果，而采用递归的方式去计算所需要的那一个数的话，多级的递归调用带来的成本却也是异常昂贵的。

那么，如果现在需要的不仅仅是每次只用一个斐波那契数，而且还是按数列中的顺序用的，这个问题就会有一个比较好的解决思路。我们可以不维护保存了所有之前计算结果的list，但同时为了避免使用递归的方式计算，去维护最后一次计算的结果。比如说，算完了fab(5)，我们可以把fab(4)和fab(5)都存到x和y。这样，下次要算fab(6)的时候，就可以直接得到结果，同时把x和y换成fab(5)和fab(6)。

到这里，就应该请出文章的主角——yield关键字了。如果我们想要按上面那种思路实现fab函数，我们不必真的去手动维护x和y，而是可以使用yield，把函数写成
```python
def fab(N): 
   n, first, second = 0, 0, 1 
    while n < N: 
        yield b 
        first, second = second, first + second 
        n = n + 1 
```
这样，fab函数将会变成一个生成器。每次要用到它的值时，他就会执行一遍里面的代码。当执行到yield时，函数就会把那个值返回，同时中断当前的执行。直到下次再用到fab的值时，它会恢复到上次中断前一模一样的上下文，然后继续执行yield后面的代码。yield就好比debug时的断点，中断了函数的执行，让开发者能查看此时的变量值，确认无误后，还可以继续执行。而此时的执行和没有被中断过的完全一致。
# 碎碎念
在计算机科学领域中，空间和时间的互换是解决问题再常见不过的手段。解算法题时暴力简单的打表法就是其中的代表。这里的生成式和生成器同样也很好地体现了这一点。